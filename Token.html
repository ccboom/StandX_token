<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StandX Local Auth Tool</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; line-height: 1.5; background-color: #f4f4f9; }
        .card { background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); margin-bottom: 1rem; }
        h1 { margin-top: 0; color: #333; }
        h3 { border-bottom: 1px solid #eee; padding-bottom: 0.5rem; color: #555; }
        button { background-color: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 1rem; margin-right: 10px; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .field { margin-bottom: 1rem; }
        label { display: block; font-weight: bold; margin-bottom: 0.5rem; font-size: 0.9rem; color: #666; }
        textarea, input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 0.9rem; box-sizing: border-box; }
        textarea { height: 80px; resize: vertical; }
        .highlight { border-color: #28a745; background-color: #f0fff4; }
        #logs { background: #333; color: #0f0; padding: 1rem; border-radius: 4px; height: 200px; overflow-y: auto; font-family: monospace; font-size: 0.85rem; }
        .sensitive { color: #d9534f; font-weight: bold; }
    </style>
</head>
<body>

    <div class="card">
        <h1>StandX Auth & Key Generator</h1>
        <p>此工具在本地生成 Ed25519 密钥对，并使用 MetaMask 登录 StandX 获取 Token。</p>
        
        <div class="field">
            <button id="btnConnect">1. 连接 MetaMask & 生成密钥</button>
            <button id="btnLogin" disabled>2. 签名并登录</button>
        </div>
    </div>

    <div class="card">
        <h3>结果输出 (复制这些信息)</h3>
        
        <div class="field">
            <label for="outToken">API Access Token (JWT):</label>
            <textarea id="outToken" readonly onclick="this.select()"></textarea>
        </div>

        <div class="field">
            <label for="outPrivKey" class="sensitive">Ed25519 Private Key (Hex): <span style="font-weight:normal; font-size:0.8em; color:#666">用于代码中的 Body 签名</span></label>
            <input type="text" id="outPrivKey" class="highlight" readonly onclick="this.select()">
        </div>

        <div class="field">
            <label for="outRequestId">Request ID (Public Key Base58):</label>
            <input type="text" id="outRequestId" readonly onclick="this.select()">
        </div>
		
		<div class="field">
            <label for="Numlist">Private Key:</label>
            <input type="text" id="Numlist" class="highlight" readonly onclick="this.select()">
        </div>
    </div>

    <div class="card">
        <h3>运行日志</h3>
        <div id="logs"></div>
    </div>

    <!-- 引入 Ethers.js 和 Crypto 库 -->
    <script type="module">
        import { ethers } from "https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.min.js";
        import { ed25519 } from "https://esm.sh/@noble/curves@1.2.0/ed25519";
        import { base58 } from "https://esm.sh/@scure/base@1.1.3";

        // 全局变量存储
        let state = {
            walletAddress: null,
            ed25519Priv: null,
            ed25519Pub: null,
            requestId: null, // Base58 encoded Public Key
            signedData: null,
            messageToSign: null
        };

        const DOM = {
            btnConnect: document.getElementById('btnConnect'),
            btnLogin: document.getElementById('btnLogin'),
            logs: document.getElementById('logs'),
            outToken: document.getElementById('outToken'),
            outPrivKey: document.getElementById('outPrivKey'),
            outRequestId: document.getElementById('outRequestId'),
            Numlist: document.getElementById('Numlist')
        };

        function log(msg, type = 'info') {
            const time = new Date().toLocaleTimeString();
            const line = document.createElement('div');
            line.textContent = `[${time}] ${msg}`;
            if(type === 'error') line.style.color = '#ff6b6b';
            DOM.logs.appendChild(line);
            DOM.logs.scrollTop = DOM.logs.scrollHeight;
        }

        function bytesToHex(bytes) {
            return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        }
		
		function fromBase58(string) {
            const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
            const ALPHABET_MAP = {};
            for(let i = 0; i < ALPHABET.length; i++) ALPHABET_MAP[ALPHABET.charAt(i)] = i;

            if (string.length === 0) return new Uint8Array(0);

            let i, j, bytes = [0];
            for (i = 0; i < string.length; i++) {
                const c = string[i];
                if (!(c in ALPHABET_MAP)) throw new Error('Base58 string contains invalid character: ' + c);

                for (j = 0; j < bytes.length; j++) bytes[j] *= 58;
                bytes[0] += ALPHABET_MAP[c];

                let carry = 0;
                for (j = 0; j < bytes.length; ++j) {
                    bytes[j] += carry;
                    carry = bytes[j] >> 8;
                    bytes[j] &= 0xff;
                }
                while (carry) {
                    bytes.push(carry & 0xff);
                    carry >>= 8;
                }
            }

            // Deal with leading zeros
            for (i = 0; i < string.length && string[i] === '1'; i++) bytes.push(0);

            return new Uint8Array(bytes.reverse());
        }

        // 1. 初始化 & 生成密钥
        DOM.btnConnect.addEventListener('click', async () => {
            try {
                log("正在生成 Ed25519 密钥对...");
                
                // 生成临时密钥对
                const privKey = ed25519.utils.randomPrivateKey();
                const pubKey = ed25519.getPublicKey(privKey);
                
                state.ed25519Priv = privKey;
                state.ed25519Pub = pubKey;
                // 将公钥编码为 Base58 作为 requestId
                state.requestId = base58.encode(pubKey);
				console.log(privKey);
				console.log(bytesToHex(privKey));

                // 显示私钥 (Hex格式，方便用户复制到代码中使用)
                DOM.outPrivKey.value = bytesToHex(privKey);
                DOM.outRequestId.value = state.requestId;
				
				let output = ""; // 开始的大括号
				const itemsPerRow = 8; // 每行显示8个

				// Uint8Array 可以像数组一样使用 forEach 遍历
				privKey.forEach((value, index) => {

				// 1. 判断是否是最后一个元素
				// privateKey.length 是 32，最后一个元素的索引是 31
				const isLast = index === privKey.length - 1;

				// 2. 决定要不要加逗号
				// 如果是最后一个，用空字符串 ""；否则用逗号 ","
				const separator = isLast ? "" : ",";

				// 3. 处理 Key 的对齐 (保持不变)
				const keyStr = String(index).padStart(2, ' ');

				// 4. 处理 Value 的对齐 (关键修改)
				// 我们把数值和(可能的)逗号拼在一起，然后统一占位长度
				// '255,' 是 4 个字符，所以 padEnd 设为 4 或 5 都可以保持整齐
				const valStr = (value + separator).padEnd(4, ' ');

				// 5. 拼接
				output += `  ${keyStr}: ${valStr}`;

				// 6. 换行逻辑：满8个就换行
				if ((index + 1) % itemsPerRow === 0) {
					output += "\n";
				}
				});
								
				console.log(output);
				
				DOM.Numlist.value = output;

                log("Ed25519 密钥生成完毕。RequestId: " + state.requestId);

                // 连接 MetaMask
                if (!window.ethereum) throw new Error("未检测到 MetaMask，请安装插件。");
                
                log("请求连接钱包...");
                const provider = new ethers.BrowserProvider(window.ethereum);
                const signer = await provider.getSigner();
                state.walletAddress = await signer.getAddress();
                
                log(`钱包已连接: ${state.walletAddress}`);
                DOM.btnConnect.disabled = true;
                DOM.btnLogin.disabled = false;
                
                // 自动执行第一步 API 请求
                await prepareSignIn();

            } catch (error) {
                log(error.message, 'error');
                console.error(error);
            }
        });

        // 2. 调用 Prepare Sign-in API
        async function prepareSignIn() {
            try {
                log("正在请求服务器预签名数据 (prepare-signin)...");
                const chain = "bsc"; 
                const url = `https://api.standx.com/v1/offchain/prepare-signin?chain=${chain}`;

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        address: state.walletAddress,
                        requestId: state.requestId
                    })
                });

                const data = await response.json();
                
                if (!data.success) throw new Error("API 请求失败: " + JSON.stringify(data));
                
                state.signedData = data.signedData;
                log("获取 signedData 成功。");

                // 解析 JWT Payload 获取需要签名的 message
                const parts = state.signedData.split('.');
                const payload = JSON.parse(atob(parts[1]));
                state.messageToSign = payload.message;
                
                log("解析签名消息成功。准备签名...");

            } catch (error) {
                log("准备登录失败: " + error.message, 'error');
                DOM.btnLogin.disabled = true;
            }
        }

        // 3. 签名并登录
        DOM.btnLogin.addEventListener('click', async () => {
            try {
                if (!state.messageToSign) throw new Error("未获取到待签名消息");

                const provider = new ethers.BrowserProvider(window.ethereum);
                const signer = await provider.getSigner();

                log("请在 MetaMask 中签名消息...");
                // 对应文档中的 Steps 4: Sign the Message
                const signature = await signer.signMessage(state.messageToSign);
                log("签名完成。");

                // 提交登录
                log("正在提交登录请求 (login)...");
                const chain = "bsc";
                const loginUrl = `https://api.standx.com/v1/offchain/login?chain=${chain}`;

                const loginResponse = await fetch(loginUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        signature: signature,
                        signedData: state.signedData,
                        expiresSeconds: 604800 // 7天
                    })
                });

                const loginResult = await loginResponse.json();

                if (loginResult.token) {
                    log("登录成功！", 'success');
                    DOM.outToken.value = loginResult.token;
                    DOM.outToken.classList.add('highlight');
					
                    log("=== 流程结束，请复制 Token 和 Private Key 使用 ===");
                } else {
                    throw new Error("登录失败: " + JSON.stringify(loginResult));
                }

            } catch (error) {
                log(error.message, 'error');
            }
        });

    </script>
</body>
</html>
